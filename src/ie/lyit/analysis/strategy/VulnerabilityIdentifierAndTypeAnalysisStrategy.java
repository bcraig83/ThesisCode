package ie.lyit.analysis.strategy;

import https.www_owasp_org.index_php.owasp_dependency_check.Analysis;
import https.www_owasp_org.index_php.owasp_dependency_check.Analysis.Dependencies.Dependency.Vulnerabilities.Vulnerability;
import ie.lyit.analysis.factory.Factory;
import ie.lyit.analysis.factory.VulnerabilityTypeListFactory;
import ie.lyit.analysis.strategy.utility.AnalysisUtil;
import ie.lyit.domain.AnalysisResult;
import ie.lyit.domain.VulnerabilityType;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

/**
 * The Class VulnerabilityIdentifierAndTypeAnalysisStrategy.
 */
public class VulnerabilityIdentifierAndTypeAnalysisStrategy extends AbstractAnalysisStrategy {

	// TODO: there is commonality here between this strategy and
	// VulnerabilityTypeDistributionAnalysisStrategy; need to refactor to reduce
	// duplication
	private List<VulnerabilityType> vulnerabilityTypeList;

	private Factory<List<VulnerabilityType>> vulnerabilityTypeListFactory = new VulnerabilityTypeListFactory();

	/* (non-Javadoc)
	 * @see ie.lyit.analysis.strategy.AbstractAnalysisStrategy#initialise()
	 */
	@Override
	protected void initialise() {

		AnalysisResult ar = getAnalysisResult();

		ar.setNameOfAnalysis("Vulnerability Type");
		ar.setTypeOfItemOfInterest("Vulnerability Identifer");

		vulnerabilityTypeList = vulnerabilityTypeListFactory.create();
	}

	// TODO: there's a known bug here, in the fact that it can output a single
	// vulnerability multiple times. I can get around this for now by removing
	// duplicates in excel, but obviously would be better to handle it here
	// On closer inspection, it look like every vulnerability is added twice,
	// pointing to a light mistake somewhere in the looping logic (where it's
	// adding something twice every single time)
	// REMEMBER - this method is actually called from within a loop itself...
	/* (non-Javadoc)
	 * @see ie.lyit.analysis.strategy.AbstractAnalysisStrategy#runSpecificAnalysis(https.www_owasp_org.index_php.owasp_dependency_check.Analysis)
	 */
	@Override
	protected void runSpecificAnalysis(Analysis analysis) {

		Map<String, Vulnerability> uniqueVulnerabilites = AnalysisUtil.extractUniqueVulnerabilities(analysis);

		// System.out.println(uniqueVulnerabilites);

		Iterator<Entry<String, Vulnerability>> it = uniqueVulnerabilites.entrySet().iterator();

		while (it.hasNext()) {

			Map.Entry pairs = it.next();

			Vulnerability vulnerability = (Vulnerability) pairs.getValue();

			AnalysisResult ar = getAnalysisResult();

			String name = vulnerability.getName();
			String description = vulnerability.getDescription();

			for (VulnerabilityType vulnerabilityType : vulnerabilityTypeList) {
				List<String> identifiers = vulnerabilityType.getIdentifiers();

				for (String identifier : identifiers) {

					if (description.toLowerCase().contains(identifier.toLowerCase())) {
						ar.add(name, vulnerabilityType.getName());
						break;
					}
				}
			}

			if (!ar.getStringMap().containsKey(name)) {
				ar.add(name, description);
			}
		}
	}
}